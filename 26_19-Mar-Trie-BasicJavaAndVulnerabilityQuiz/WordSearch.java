// Imagine you're an adventurer with a mystical treasure map. This map is a grid of 
// ancient runes, where each cell holds a single character. Legend has a 
// powerful incantation—represented as a string—is hidden within these runes. 
// To unlock the treasure, you must verify if the incantation exists on the map.

// The incantation is formed by linking runes that are directly next to each other 
// either horizontally or vertically. Each rune on the map can only be used once in
// the incantation.

// Your Task:  
// Given an m x n grid representing the treasure map and a string representing the 
// incantation, return true if the incantation can be traced on the map; 
// otherwise, return false.


// Example 1:
// ----------
// Input:  
// 3 4
// ABCD
// SFCS
// ADEE
// ABCCED

// Output:
// ABCCED can be traced

// Explanation (check hint)
// Treasure Map Grid:  
// [
//   ["A", "B", "C", "E"],
//   ["S", "F", "C", "S"],
//   ["A", "D", "E", "E"]
// ]

// Incantation: "ABCCED" exists in map


// Example 2:
// ----------
// Input:
// 3 4
// ABCE
// SFCS
// ADEE
// ABCB

// Output: 
// ABCB cannot be traced

// Explanation:
// Treasure Map Grid:  

// [
//   ["A", "B", "C", "E"],
//   ["S", "F", "C", "S"],
//   ["A", "D", "E", "E"]
// ]

// Incantation: "ABCB" does not exist in map


// Constraints:

// - m == the number of rows in the grid  
// - n == the number of columns in the grid  
// - 1 <= m, n <= 6  
// - 1 <= incantation length <= 15  
// - The grid and incantation consist only of uppercase and lowercase English letters.

import java.util.*;
public class WordSearch{
    public static boolean check(char[][] arr,int m,int n,String query){
        boolean flag = false;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(arr[i][j]==query.charAt(0)){
                    flag = dfs(arr,i,j,query,0);
                    if(flag) return true;
                }
            }
        }
        return flag;
    }
    public static boolean dfs(char arr[][],int i,int j,String query,int curr){
        if(curr==query.length()) return true;
        if(i<0 || j<0 || i>=arr.length || j>=arr[0].length || arr[i][j]=='0' || arr[i][j]!=query.charAt(curr)) return false;
        char temp = arr[i][j];
        arr[i][j] = '0';
        boolean flag = dfs(arr,i+1,j,query,curr+1) || dfs(arr,i-1,j,query,curr+1) || dfs(arr,i,j+1,query,curr+1) || dfs(arr,i,j-1,query,curr+1); 
        if(flag) return true;
        arr[i][j] = temp;
        return false;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        char[][] arr = new char[m][n];
        for(int i=0;i<m;i++){
            String s = sc.next();
            arr[i] = s.toCharArray();
        }
        String query = sc.next();
        System.out.println(check(arr,m,n,query)?query + " can be traced" : query + " cannot be traced");
        sc.close();
    }
}